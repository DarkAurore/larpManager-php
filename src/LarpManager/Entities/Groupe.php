<?php

/**
 * Auto generated by MySQL Workbench Schema Exporter.
 * Version 2.1.6-dev (doctrine2-annotation) on 2015-06-30 20:35:19.
 * Goto https://github.com/johmue/mysql-workbench-schema-exporter for more
 * information.
 */

namespace LarpManager\Entities;

use Doctrine\Common\Collections\ArrayCollection;
use LarpManager\Entities\BaseGroupe;

/**
 * Je définie les relations ManyToMany içi au lieu de le faire dans Mysql Workbench
 * car l'exporteur ne sait pas gérer correctement les relations ManyToMany ayant des 
 * paramètres autre que les identifiant des tables concernés (c'est dommage ...)
 * 
 * LarpManager\Entities\Groupe
 *
 * @Entity(repositoryClass="LarpManager\Repository\GroupeRepository")
 */
class Groupe extends BaseGroupe
{
	/**
	 * Contructeur.
	 * 
	 * Défini le nombre de place disponible à 0
	 */
	public function __construct()
	{		
		$this->setClasseOpen(0);
		$this->setLock(false);
		parent::__construct();
	}
	
	/**
	 * méthode magique transtypage en string
	 * 
	 * @return string
	 */
	public function __toString()
	{
		return $this->getNom();	
	}
	
	/**
	 * Determine si un groupe est allié avec ce groupe
	 * @param Groupe $groupe
	 */
	public function isAllyTo(Groupe $groupe)
	{
		foreach ( $this->getAlliances() as $alliance)
		{
			if ($alliance->getGroupe() == $groupe
				|| $alliance->getRequestedGroupe() == $groupe )
			{
				return true;
			}
		}
		return false;
	}
	
	/**
	 * Determine si un groupe est en attente d'alliance avec ce groupe
	 * @param Groupe $groupe
	 * @return boolean
	 */
	public function isWaitingAlliance(Groupe $groupe)
	{
		foreach ( $this->getWaitingAlliances() as $alliance)
		{
			if ($alliance->getGroupe() == $groupe
					|| $alliance->getRequestedGroupe() == $groupe )
			{
				return true;
			}
		}
		return false;
	}
	
	/**
	 * Determine si un groupe est ennemi avec ce groupe
	 * @param Groupe $groupe
	 */
	public function isEnemyTo(Groupe $groupe)
	{
		foreach ( $this->getEnnemies() as $war)
		{
			if ($war->getGroupe() == $groupe
				|| $war->getRequestedGroupe() == $groupe )
			{
				return true;
			}
		}
		return false;
	}
	
	/**
	 * Determine si un groupe est ennemi avec ce groupe
	 * @param Groupe $groupe
	 */
	public function isWaitingPeaceTo(Groupe $groupe)
	{
		foreach ( $this->getWaitingPeace() as $war)
		{
			if ($war->getGroupe() == $groupe
					|| $war->getRequestedGroupe() == $groupe )
			{
				return true;
			}
		}
		return false;
	}
	
	/**
	 * Fourni la liste des toutes les alliances de ce groupe
	 */
	public function getAlliances()
	{
		$alliances = new ArrayCollection();
		
		foreach ( $this->groupeAllieRelatedByGroupeIds as $alliance)
		{
			if ( $alliance->getGroupeAccepted() && $alliance->getGroupeAllieAccepted() )
			{
				$alliances[] = $alliance;
			}
		}
		
		foreach ( $this->groupeAllieRelatedByGroupeAllieIds as $alliance)
		{
			if ( $alliance->getGroupeAccepted() && $alliance->getGroupeAllieAccepted() )
			{
				$alliances[] = $alliance;
			}
		}
		
		return $alliances;
	}
	
	/**
	 * Fourni la liste de toutes les alliances en cours de négotiation 
	 */
	public function getWaitingAlliances()
	{
		$alliances = new ArrayCollection();
		
		foreach ( $this->groupeAllieRelatedByGroupeIds as $alliance)
		{
			if ( ! $alliance->getGroupeAccepted() || ! $alliance->getGroupeAllieAccepted() )
			{
				$alliances[] = $alliance;
			}
		}
		
		foreach ( $this->groupeAllieRelatedByGroupeAllieIds as $alliance)
		{
			if ( ! $alliance->getGroupeAccepted() || ! $alliance->getGroupeAllieAccepted() )
			{
				$alliances[] = $alliance;
			}
		}
		
		return $alliances;
	}
	
	/**
	 * Fourni la liste de toutes les demandes d'alliances
	 */
	public function getRequestedAlliances()
	{
		$alliances = new ArrayCollection();
		
		foreach ( $this->groupeAllieRelatedByGroupeAllieIds as $alliance)
		{
			if ( ! $alliance->getGroupeAllieAccepted() )
			{
				$alliances[] = $alliance;
			}
				
		}
		return $alliances;
	}
	
	/**
	 * Fourni la liste de toutes les alliances demandés
	 */
	public function getSelfRequestedAlliances()
	{
		$alliances = new ArrayCollection();
		
		foreach ( $this->groupeAllieRelatedByGroupeIds as $alliance)
		{
			if ( ! $alliance->getGroupeAllieAccepted() )
			{
				$alliances[] = $alliance;
			}
		
		}
		return $alliances;		
	}
	
	/**
	 * Fourni tous les ennemis du groupe
	 */
	public function getEnnemies()
	{
		$enemies = new ArrayCollection();
		
		foreach ( $this->groupeEnemyRelatedByGroupeIds as $enemy)
		{
			if ( $enemy->getGroupePeace() == false || $enemy->getGroupeEnemyPeace() == false )
			{
				$enemies[] = $enemy;
			}			
		}
		
		foreach ( $this->groupeEnemyRelatedByGroupeEnemyIds as $enemy)
		{
			if ( $enemy->getGroupePeace() == false || $enemy->getGroupeEnemyPeace() == false )
			{
				$enemies[] = $enemy;
			}
		}
		
		return $enemies;
	}
	
	/**
	 * Fourni la liste des anciens ennemis
	 */
	public function getOldEnemies()
	{
		$enemies = new ArrayCollection();
		
		foreach ( $this->groupeEnemyRelatedByGroupeIds as $enemy)
		{
			if ( $enemy->getGroupePeace() == true && $enemy->getGroupeEnemyPeace() == true )
			{
				$enemies[] = $enemy;
			}
		}
		
		foreach ( $this->groupeEnemyRelatedByGroupeEnemyIds as $enemy)
		{
			if ( $enemy->getGroupePeace() == true && $enemy->getGroupeEnemyPeace() == true )
			{
				$enemies[] = $enemy;
			}
		}
		
		return $enemies;
	}
	
	/**
	 * Fournie toutes les negociation de paix en cours
	 */
	public function getWaitingPeace()
	{
		$enemies = new ArrayCollection();
		
		foreach ( $this->groupeEnemyRelatedByGroupeIds as $enemy)
		{
			if ( ( $enemy->getGroupePeace() == true || $enemy->getGroupeEnemyPeace() == true)
				&& (! ( $enemy->getGroupePeace() == true && $enemy->getGroupeEnemyPeace() == true)) )
			{
				$enemies[] = $enemy;
			}
		}
		
		foreach ( $this->groupeEnemyRelatedByGroupeEnemyIds as $enemy)
		{
			if ( ( $enemy->getGroupePeace() == true || $enemy->getGroupeEnemyPeace() == true)
				&& (! ( $enemy->getGroupePeace() == true && $enemy->getGroupeEnemyPeace() == true)) )
			{
				$enemies[] = $enemy;
			}
		}
		
		return $enemies;
	}
	
	/**
	 * Trouve le personnage de l'utilisateur dans ce groupe
	 * 
	 * @param User $user
	 */
	public function getPersonnage(User $user)
	{
		$participant = $user->getParticipantByGroupe($this);
		if ( $participant )
		{
			return $participant->getPersonnage();
		}
		return null;
	}
	
	/**
	 * Vérifie si le groupe dispose de suffisement de place disponible
	 * 
	 * @return boolean
	 */
	public function hasEnoughPlace()
	{
		return $this->getClasseOpen() > count($this->getPersonnages());
	}
	
	/**
	 * Vérifie si le groupe dispose de suffisement de classe disponible
	 */
	public function hasEnoughClasse()
	{
		return  ( count($this->getAvailableClasses()) > 0 );
	}
	
	/**
	 * Fourni la liste des classes disponibles (non actuellement utilisé par un personnage)
	 * Ce type de liste est utile pour le formulaire de création d'un personnage
	 * 
	 * @return Collection LarpManager\Entities\Classe
	 */
	public function getAvailableClasses()
	{		
		$groupeClasses = $this->getGroupeClasses();
		$base = clone $groupeClasses;
		
		foreach ( $this->getPersonnages() as $personnage)
		{
			$id = $personnage->getClasse()->getId();
			
			foreach (  $base as $key => $groupeClasse)
			{
				if ( $groupeClasse->getClasse()->getId() == $id )
				{
					unset($base[$key]);
					break;
				}
			}
		}

		$availableClasses = array();
		
		foreach ( $base as $groupeClasse)
		{
			$availableClasses[] = $groupeClasse->getClasse();
		}

		return $availableClasses;	
	}			
	
	/**
	 * Get User entity related by `responsable_id` (many to one).
	 *
	 * @return \LarpManager\Entities\User
	 */
	public function getResponsable()
	{
		return $this->getUserRelatedByResponsableId();
	}
	
	/**
	 * Set User entity related by `responsable_id` (many to one).
	 * Le responsable est aussi membre du groupe
	 *
	 * @param \LarpManager\Entities\User $user
	 * @return \LarpManager\Entities\Groupe
	 */
	public function setResponsable($user)
	{
		if ( $user) $user->addGroupeRelatedByResponsableId($this);
		return $this->setUserRelatedByResponsableId($user);
	}
	
	/**
	 * Get User entity related by `scenariste_id` (many to one).
	 *
	 * @return \LarpManager\Entities\User
	 */
	public function getScenariste()
	{
		return $this->getUserRelatedByScenaristeId();
	}
	
	/**
	 * Set User entity related by `scenariste_id` (many to one).
	 *
	 * @param \LarpManager\Entities\User $user
	 * @return \LarpManager\Entities\Groupe
	 */
	public function setScenariste($user)
	{
		return $this->setUserRelatedByScenaristeId($user);
	}
	
	/**
	 * Fourni la liste des classes
	 * 
	 * @return Array LarpManager\Entities\Classe
	 */
	public function getClasses()
	{
		$classes = array();
		$groupeClasses =  $this->getGroupeClasses();
		foreach ( $groupeClasses as $groupeClasse)
		{
			$classes[] = $groupeClasse->getClasse();
		}
		return $classes;
	}
	
	/**
	 * Ajoute une classe dans le groupe
	 * 
	 * @param GroupeClasse $groupeClasse
	 */
	public function addGroupeClass(GroupeClasse $groupeClasse)
	{
		return $this->addGroupeClasse($groupeClasse);
	}
	
	/**
	 * Retire une classe du groupe
	 * @param GroupeClasse $groupeClasse
	 */
	public function removeGroupeClass(GroupeClasse $groupeClasse)
	{
		return $this->removeGroupeClasse($groupeClasse);
	}
	
}